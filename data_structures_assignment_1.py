# -*- coding: utf-8 -*-
"""data structures assignment 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o2EQD9n-XWs4ZXrx26AJu_Ml5IO37nOm
"""

import random #importing random so I could shuffle and randomize the given chocolates

def Iterative(chocolates, students): #starting with the iterative function
    if len(chocolates) < len(students): #Using if statement to say that if the number of chocolates is less than number of students
        print("Not enough chocolates for each student.") #it would print not enough chocolates
        return

    random.shuffle(chocolates) #randomly shuffling the chocolates

    for i in range(len(students)): #using for loop so it would iterate over all the students and give them random chocolates
        print(f"{students[i]} : {chocolates[i]['type']} chocolate (weight: {chocolates[i]['weight']} gm, price: {chocolates[i]['price']} AED)") #printing the statement. i represents the random element in student and chocolate

def recursive(chocolates, students, idx=0): #recursive function
    if idx == len(students) or idx == len(chocolates): #this line checks if the index is equal to the length of students of chocolates by breaking them down into sub-problems so we could continue on with the process
        return

    random_index = random.randint(idx, len(chocolates) - 1) #randomizing the index and distribution process using random.randit
    chocolates[idx], chocolates[random_index] = chocolates[random_index], chocolates[idx]

    print(f"{students[idx]} : {chocolates[idx]['type']} chocolate (weight: {chocolates[idx]['weight']} gm, price: {chocolates[idx]['price']} AED)") #printing the fucntion with the weight and prices just like the iterative one

    recursive(chocolates, students, idx+1) #calling the function and making sure this statement conitnues and passes through all the students and chocolates

# Test cases
#iterative
chocolates = [
    {'type': 'milk chocolate', 'weight': 2, 'price': 4},
    {'type': 'caramel chocolate', 'weight': 3, 'price': 5},
    {'type': 'almond chocolate', 'weight': 4, 'price': 3},
    {'type': 'dark chocolate', 'weight': 5, 'price': 2},
    {'type': 'white chocolate', 'weight': 7, 'price': 1}
]

students = ['Noora', 'Hessa', 'Hind', 'Maryam', 'Aisha']

print("Iterative Distribution:")
Iterative(chocolates, students)

#recursive
chocolates = [
    {'type': 'milk chocolate', 'weight': 2, 'price': 4},
    {'type': 'caramel chocolate', 'weight': 3, 'price': 5},
    {'type': 'almond chocolate', 'weight': 4, 'price': 3},
    {'type': 'dark chocolate', 'weight': 5, 'price': 2},
    {'type': 'white chocolate', 'weight': 7, 'price': 1}
]

students = ['Noora', 'Hessa', 'Hind', 'Maryam', 'Aisha']

print("recursive Distribution:")
recursive(chocolates, students)

"""1) Chocolate Distribution Algorithm, test cases, complexity analysis

In part 1, I wrote two functions for giving the chocoaltes which are iterative and recursive function. In the iterative, it would go over everything in a loop form till every student has a piece of chocolate, In the recursive it would break down the problem into pieces so it would be easier to solve. I provided test cases to prove my point and saw that both functions worked in a different matter however gave similar answers with the choclates being randomly suffled as I wanted. The time complexity for the iterative function would be O(n). In the worst-case scenario, it iterates and visits every single element. The best case scenario would be that the chocolates and students as already sorted out. In the recursive function, I would say that the time complexity is O(n)^2 because it visits each element once and since it swaps the elements as well it creates more complexity. The worst case scenario would be that the code would randomly select a piece of chocolate for each student taking more time. The best case would be that the list is already sorted out and has a good outcome. The average case would remain as O(n)^2 because the randomness of the algorithm would still take time to go from student to student and from chocolate to chocoate.
"""

def merge_sort(chocolates, key='weight'): #using mergesort for the chocolates and using key to pick one of the attributes that I want which is weight
    if len(chocolates) <= 1: #using the if statement and checking if the length of the chocolates list is less than or equal to 1.
        return chocolates #it means there's only one chocolate or none, which is already sorted, so it returns the chocolates list

    mid = len(chocolates) // 2 #I calculated the midpoint index of the chocolates list to divide it into two halves for merge sort.
    left_half = merge_sort(chocolates[:mid], key) #calling the chocolates in a recursive order on the left side and stopping at the mid point
    right_half = merge_sort(chocolates[mid:], key) #calling the chocolates in a recursive order on the right side and stopping at the mid point

    return merge(left_half, right_half, key) #returning the function

def merge(left, right, key): #I will merge the left and right of the weight distribution after being sorted out
    result = [] #cretaing an empty list to store the merged result
    left_idx = right_idx = 0 #creating pointers for the left index and right index to track the current position in each list.

    while left_idx < len(left) and right_idx < len(right): #using while loop to compare all elements in the left and right till there's nothing left
        if left[left_idx][key] < right[right_idx][key]: #using if statement to compare the elements at the current positions of the weights of the left index and right index
            result.append(left[left_idx]) #if the element in the left list is smaller, it is appended to the result list
            left_idx += 1 #the left_idx pointer is incremented.
        else:
            result.append(right[right_idx]) #if the element in the right list is smaller or equal, it is appended to the result list
            right_idx += 1 #the right_idx pointer is incremented.

    result.extend(left[left_idx:]) #This line extends the result list by appending all the remaining elements from the left list to the end of the list.
    result.extend(right[right_idx:]) ##This line extends the result list by appending all the remaining elements from the right list to the end of the list.
    return result #returning the result list

# Sorting chocolates by weight and price
chocolates_sorted_by_weight = merge_sort(chocolates, 'weight')
chocolates_sorted_by_price = merge_sort(chocolates, 'price')

#test cases

# Printing chocolates sorted by weight
print("Chocolates sorted by weight:")
for chocolate in chocolates_sorted_by_weight: #for loop to iterate and print every weight of the chocolate
    print(f" {chocolate['type']}, Weight: {chocolate['weight']} gm")

# Printing chocolates sorted by price
print("Chocolates sorted by price:")
for chocolate in chocolates_sorted_by_price: #for loop to iterate and print every price of the chocolate
    print(f" {chocolate['type']}, Price: {chocolate['price']} AED")

"""2) sorting the chocolate, test cases & complexity analysis

In part 2, it was asked for us to use any kind of sorting function to sort out the chcolates by weight and price. I used merge sort since its basically divide and conquer and it worked by dividing the list into half and sorting it out then merging it together (as shown in the code). The scalability of using the merge sort for this algorithm would still be efficient even on operating with large datasets since merge sorts divides the list and solves it using a simplistic manner then regroups or merges it together. The test cases show that the code works perfectly and it prints out the chocolates sorted out by weight and price individually. The complexity analysis would be that the time complexity is O(nlogn) since the divide and combine steps are O(log n) and the conquer step is O(n). Best case scneario is that the lsit is already sorted, no need to divide it. Average case would be that some of the elements are sorted therefore we still need to sort some others to complete the task. Worst-case scenario is the list needs to be divided into sub-parts and sorted out.
"""

def search_chocolate(students, chocolates, key, value): #using the search function for list students,  choclates and their key attributes which in this case would be weight and price and the specific value I'm searching for
    left = 0 #left side would be initialzied as 0
    right = len(chocolates) - 1 #right side would be the index of the last element in the chocolates list

    while left <= right: #while loop that continues as long as left is less than or equal to right to ensure space

        mid = (left + right) // 2 #Calculate the midpoint of the search space by adding the left and right side and dividing it by 2
        if chocolates[mid][key] == value: #using if statement to see that if the chocolate at the midpoint has the desired value for the specified key
            return students[mid] # return the corresponding student from the students list.
        elif chocolates[mid][key] < value: #if the value of the key for the chocolate at the midpoint is less than the desired value
            left = mid + 1 # search the right half of the remaining list.
        else: #If the value of the key for the chocolate at the midpoint is greater than the desired value
            right = mid - 1 # search the left half of the remaining list.

    return None #if the while loop exits without finding the desired value, return None


# Test Cases
chocolates = [
    {"type": "milk", "weight": 2, "price": 4},
    {"type": "caramel", "weight": 3, "price": 5},
    {"type": "almond", "weight": 4, "price": 3},
    {"type": "dark", "weight": 5, "price": 2},
    {"type": "white", "weight": 7, "price": 1}
]
students = ["Noora", "Hessa", "Hind", "Maryam", "Aisha"]

# Test searching by weight
weight_to_find = 3 #adding the specified weight value
student_with_weight = search_chocolate(students, chocolates, 'weight', weight_to_find)
print(f" {student_with_weight} is the student that is holding a chocolate with the weight of {weight_to_find} gm")

weight_to_find = 7
student_with_weight = search_chocolate(students, chocolates, 'weight', weight_to_find)
print(f" {student_with_weight} is the student that is holding a chocolate with the weight of {weight_to_find} gm")

# Test searching by price
price_to_find = 3 #adding the speicifed price value
student_with_price = search_chocolate(students, chocolates, 'price', price_to_find)
print(f" {student_with_price} is the student that is holding a chocolate with the price of {price_to_find} AED")

price_to_find = 0
student_with_price = search_chocolate(students, chocolates, 'price', price_to_find)
print(f" {student_with_price} is the student that is holding a chocolate with the price of {price_to_find} AED")

"""3) searching for a specific chocolate, test acses & complexity analysis

In part 3, we were asked to find the students that are holding the chocolate with a specified weight and price (binary search). I used the search function to find the student. The assumption is that the chocolate is already sorted by weight in my code as shown. Therefore when I did the test cases, I put on a specific number of weight or price and it gave me back the name of the student sorted on the list that holds the item. The time complexity is O(log n) in the worst-case scenario because it takes time to find the chocolate with the specified price or weight in the sorted list of chocolates. The best-case scenario for binary search is when the target element is found at the middle of the list. The average case is that the time complexity stays O(log n) since the search still iterates through every chocolate's weight and price and eliminates till it finds the one. The worst-case scenario occurs when the target element is either the smallest or largest element in the list
"""